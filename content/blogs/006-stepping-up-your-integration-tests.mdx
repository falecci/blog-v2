export const metadata = {
  title: "Stepping up your integration tests",
  publishDate: "2025-01-27",
  description:
    "A practical guide to writing better integration tests with React Testing Library, MSW, and Vitest.",
  draft: true
};

If you've ever found yourself drowning in unit tests that mock everything, or spending hours debugging why your tests pass but your app fails in production, this post is for you.

We're going to dive into a testing philosophy that focuses on **integration tests** over unit tests, **user-centered testing** over implementation details, and **MSW** over mocking hooks. This approach has transformed how I write tests and I think it can help you too.

---

## The Philosophy: Fewer Tests, Mostly Integration

There are many perspectives on testing: unit tests, integration tests, end-to-end (E2E) tests, and models like the [*testing pyramid*](https://martinfowler.com/articles/practical-test-pyramid.html).

Personally I like following the principle of [‚ÄúWrite tests. Not too many. Mostly integration‚Äù](https://kentcdodds.com/blog/write-tests), originally coined by Guillermo Rauch (Vercel) and expanded by Kent C. Dodds. The idea is simple: tests should deliver the **most value** for the **least cost**.

Tests come with basically two types of costs:
- **CI cost** (minutes spent running tests)
- **Developer cost** (time required to write and maintain them)

There are some delusions around having **100% code coverage**. That's not realistic and actually striving to get at it might not be good ata ll. Beyond a certain point, additional coverage doesn't justify the cost.

From my point of view, focusing on integration tests gives us the **best return on investment**. Let's dive into an example.

### Example: Testing a form

Imagine a classic form with inputs, selects, and a date picker. 

We could have unit tests for each input making sure `onChange` prop has been called with the right value and else. But at the end of the day, the integration of all the parts is not actually tested and it might fail.

What if we are doing some data transformation of our form values before sending it to our API? Sure, our `<DatePicker />` component is calling `onChange` with the right date value, but we may have a bug when posting this data:

```tsx
async function onSubmit(values: FormValues) {
    const timezonelessDate = new Date().toISOString().split('T')[2] // it should be actually 0 index -> this is undefined
    if (isValidBusinessDate(timezonelessDate)) // -> ‚ùå this will throw an error
    
    // ...
}
```

Our unit tests here would give us a **false sense of security** because they would still pass but our form submission is not actually working. There is nothing worse than a _lying test_.

If you are doing this work at a company, management/product people will come biting at you asking _why the user profile form failed if you spent time writing tests?_ and it's a valid complaint. Convincing product/management to spend time on technical stuff is _super hard_ so you don't want to lose the game there.

On the other hand, we could setup E2E tests with Playwright or Cypress. In this type of tests, we get a full browser so we are fully integrated. That is awesome!

But now we need to start doing some chores like spinning up the browser, setting up an environment, logging the user in our app, cleaning the environment afterwards and else. (Note: you can mock your requests and that would avoid having to deal with a DB but then that's not truly E2E).

These chores *takes time*. Imagine if you want to test a form that has multiple branches! Now you are getting full confidence in your tests but devs are truly unhappy because they need to run a +25 minutes CI to merge their already approved work.

If you can relate with what I just explained, welcome the world of integration tests. This type of tests will let us test A LOT. Things like a page with a table that's feed data from an API, clicking on a row to open a sheet that edits the record and then asserting the record has been updated in the table.

A straightforward approach might include three separate tests:

```tsx
test("renders form fields correctly", () => { ... })
test("shows validation errors on empty submission", async () => { ... })
test("submits form with valid data", async () => { ... })
```

These tests cover:
1. Rendering form fields
2. Showing validation errors
3. Submitting valid data

Looks good ‚Äî but in reality, these three tests overlap heavily. They can actually be combined into a **single, stronger test**:

```tsx
test("submits form with valid data", async () => {
  render(<ProfilePage />);

  // Trigger validation errors
  await UserEvent.click(screen.getByRole("button", { name: /save/i }));
  expect(await screen.findByText(/username is required/i)).toBeInTheDocument();

  // Fill fields
  await UserEvent.type(screen.getByRole("textbox", { name: /username/i }), "alice");
  await UserEvent.selectOptions(screen.getByRole("combobox", { name: /manager/i }), "Michael Scott");

  // Submit successfully
  await UserEvent.click(screen.getByRole("button", { name: /save/i }));
  await expect.poll(() => screen.getByText("Profile updated")).toBeVisible();
});
```

This test checks:
- Validation errors appear
- Errors go away once fixed
- Form submission succeeds

As you can see, we are covering way more ground. And fewer tests means **lower maintenance overhead**.

PS: If you played with testing library before, you may have noticed there is no `waitFor`. We'll talk about that later.

## Why MSW?

[MSW](https://mswjs.io/) (Mock Service Worker) lets us intercept real network requests and provide handlers for queries and mutations. This way, we test **how our app actually works** ‚Äî without mocking hooks or internal logic.

---

## User-Centered Tests

We test from the **user's perspective**.

Tests should describe **user actions** (`submits a form`, `displays employee list`) rather than implementation details (`renders FormComponent`). ([reference](https://testing-library.com/docs/guiding-principles))

That's why we prefer [accessible queries](https://testing-library.com/docs/queries/about/#priority). For example:

```tsx
// ‚ùå brittle test with testids and selectors
await UserEvent.click(screen.getByTestId("save-btn"));
await UserEvent.selectOptions(screen.getByTestId("dept-combobox-1"), "sales");

// ‚úÖ better test with roles
await UserEvent.click(screen.getByRole("button", { name: /save/i }));
await UserEvent.selectOptions(screen.getByRole("combobox", { name: /department/i }), "sales");
```

Accessible queries align with what users actually see (buttons, comboboxes, labels). They also make tests easier to read and maintain.

Compare this:

```tsx
screen.getByText("Treasury balance").closest('[class*="bg-[url"]')
```

Versus this:

```tsx
screen.getByRole("button", { name: /treasury balance/i })
```

The second one is clearer, more robust, and maps directly to the user's mental model.

---

## What about E2E tests?

We talked about costs earlier. E2E tests are great but they come with some drawbacks. First you need an environment running. That means resetting a DB, waiting for an API to run, authenticate a user.

Those seems like A LOT of things just to validate our form has the right error messages after submission, right :)?

We do want E2E tests for our most critical features (where we usually rely on 3rd party services) like paying a bill. And these tests should keep it only to filling data. No elements assertion, no validation errors triggered, etc.

---

## Mocks: The Less, The Better

As outlined in our philosophy, our goal is to stay as close as possible to the **real user experience**. That means **mocking as little as we can**‚Äîwhich is exactly why we use **MSW** instead of mocking `fetch` or our `useQuery`/`useMutation` hooks.

We **never mock components** unless absolutely necessary. The only valid exception is when working with **3rd-party components we don't control** (e.g., Plaid's button that opens an iFrame).

That said, mocking is sometimes unavoidable. Since we run tests in **`jsdom`**, not a real browser, many browser APIs need to be stubbed or polyfilled. For example, we mock `ResizeObserver` in our `vitest.setup.ts`.

Another case is our `address-input` component, which uses the `react-google-autocomplete` library. This library injects a JS file dynamically, making it difficult to test cleanly without mocking.

üëâ **In short:**
- We don't mock components or hooks.
- Use **MSW** for API calls to stay realistic.
- Mock only when strictly necessary (e.g., missing browser APIs like `ResizeObserver`).

---

## Queries and Accessibility

As mentioned earlier, we prefer **role-based queries** (`getByRole`) because they align with accessibility best practices and produce clearer, more maintainable tests ([reference](https://testing-library.com/docs/queries/about#priority))

Sometimes you'll encounter multiple elements with the same **role and name**, such as an array of fields in a form. For example, in the Company Onboarding workflow, you might add multiple owners, each with a first name, last name, and address. It can be tempting to select elements by index‚Äîbut there's a cleaner solution: the `within` utility from Testing Library.

```tsx
const owner1Section = screen.getByRole('section', { name: 'Owner 1' })
const inOwner1Section = within(owner1Section)

const owner1Name = inOwner1Section.getByRole('textbox', { name: 'First Name' })
```

You can also make heavy use of **`aria-label` and `role`** for elements like icon buttons:

```tsx
<Button
  variant="secondary"
  className="w-6 h-6 flex items-center justify-center"
  aria-label="Open autopilot settings"
>
  <Stars02Icon className="!w-3 !h-3 !text-[--on-surface-stroke-secondary]" />
</Button>
```

Here, the button can be queried by the `aria-label` (`Open autopilot settings`) even though the label isn't visible on the UI. This pattern works well for cards, modals, and other interactive elements.

Ultimately, we should strive to keep elements as **semantic as possible**:

```tsx
// ‚ùå Non-semantic
<div onClick={handleSubmit} className="btn">Submit</div>

// ‚úÖ Semantic
<button onClick={handleSubmit}>Submit</button>

// ‚ùå Misusing button
<button onClick={() => navigate("/about")}>About</button>

// ‚úÖ Semantic link
<a href="/about">About</a>
<Link to="/about">About</Link>  // Next Link

// ‚ùå Overusing div
<div className="header">
  <div>Logo</div>
  <div>Menu</div>
</div>

// ‚úÖ Better: semantic wrapper
<header>
  <div>Logo</div>
  <nav>Menu</nav>
</header>

const todos = ["Buy groceries", "Walk the dog", "Read a book"];

// ‚ùå Using divs
<div className="todo-list">
  {todos.map((todo, i) => (
    <div key={i}>{todo}</div>
  ))}
</div>

// ‚úÖ Using ul/li
<ul className="todo-list">
  {todos.map((todo, i) => (
    <li key={i}>{todo}</li>
  ))}
</ul>
```

üëâ **In short:**
- Prefer **role-based queries** (`getByRole`) for accessibility alignment.
- Use `within` when multiple elements share the same labels or text.
- Keep your HTML as **semantic as possible**‚Äîit helps both users and tests.

---

## Await + findBy Instead of waitFor

When waiting for elements to appear in the DOM, always prefer the `findBy*` queries (`findByRole`, `findByText`, etc.).

### Why?
- `findBy*` queries **already include `waitFor` internally** ([reference](https://testing-library.com/docs/dom-testing-library/api-async/#findby-queries)).
- They retry until the element appears (or until the default timeout).
- This makes them more **concise** and **readable** than wrapping a `getBy*` in `waitFor`.
- For **custom assertions** on dynamic state, prefer **`expect.poll`** (Vitest) instead of `waitFor`. ([reference](https://vitest.dev/api/expect.html#poll))
- For elements that **disappear**, use `waitForElementToBeRemoved`. ([reference](https://testing-library.com/docs/dom-testing-library/api-async/#waitforelementtoberemoved))

### ‚úÖ Correct: using `findByRole`

```tsx
// Button appears after async save
await userEvent.click(screen.getByRole('button', { name: /save/i }))

// Wait for success toast
expect(await screen.findByRole('alert')).toHaveTextContent('Profile updated')
```

Here, `findByRole('alert')` automatically waits until the toast is in the DOM.

### ‚ùå Incorrect: wrapping `getBy*` in `waitFor`

```tsx
await userEvent.click(screen.getByRole('button', { name: /save/i }))

// Don't do this
await waitFor(() => {
  expect(screen.getByRole('alert')).toHaveTextContent('Profile updated')
})
```

This is redundant ‚Äî `findByRole` already does the waiting for you.

### ‚úÖ Custom assertions ‚Üí use `expect.poll`

Use `expect.poll` for polling assertions that aren't tied to element discovery.

```tsx
// Ensure button becomes disabled after click
await userEvent.click(screen.getByRole('button', { name: /save/i }))

await expect.poll(() =>
  screen.getByRole('button', { name: /save/i })
).toBeDisabled()
```

This avoids the extra `waitFor` wrapper and is more idiomatic in Vitest.

### ‚úÖ When something disappears ‚Üí use `waitForElementToBeRemoved`

`waitForElementToBeRemoved` is the most expressive way to test that elements are removed from the DOM.

```tsx
// Loading spinner disappears after data loads
await waitForElementToBeRemoved(() =>
  screen.getByRole('status', { name: /loading/i })
)
```

### ‚úÖ Example with multiple steps

```tsx
// User submits form
await userEvent.click(screen.getByRole('button', { name: /submit/i }))

// Success message appears
expect(await screen.findByText(/successfully submitted/i)).toBeVisible()

// Button becomes disabled
await expect.poll(() =>
  screen.getByRole('button', { name: /submit/i })
).toBeDisabled()

// Spinner goes away
await waitForElementToBeRemoved(() =>
  screen.getByRole('status', { name: /loading/i })
)
```

üëâ **In short:**
- Use `findBy*` for element discovery.
- Use **`expect.poll`** for dynamic assertions (enabled/disabled, value changes).
- Use `waitForElementToBeRemoved` when elements should disappear.
- Don't wrap `getBy*` with `waitFor` unless absolutely necessary.

---

## Scopes with `{}`

You can use plain `{}` blocks inside your tests to create **local scopes**.

This is useful when:
- A test has **multiple sections or steps** (e.g., a multi-step workflow, a form with multiple cards).
- You want to **reuse variable names** (e.g., `section`, `row`, `withinSection`) in different parts of the test without conflicts.
- It improves readability by clearly grouping queries and expectations by context.
- Scopes are foldable within most IDEs

### ‚úÖ Example: multi-section form

```tsx
// Accounting details section
{
  const section = screen.getByRole('section', { name: /accounting details/i })
  const inSection = within(section)

  const addressInput = inSection.getByRole('textbox', { name: /address/i })
  await userEvent.type(addressInput, '123 Main St')
  expect(addressInput).toHaveValue('123 Main St')
}

// Owner details section
{
  const section = screen.getByRole('section', { name: /owner details/i })
  const inSection = within(section)

  const firstNameInput = inSection.getByRole('textbox', { name: /first name/i })
  await userEvent.type(firstNameInput, 'Alice')
  expect(firstNameInput).toHaveValue('Alice')
}
```

Here, both blocks can safely use the same variable names (`section`, `inSection`) without clashing.

### ‚úÖ Example: re-querying rows

```tsx
// Before update
{
  const rows = screen.getAllByRole('row')
  expect(within(rows[0]).getByRole('cell', { name: /pending/i })).toBeInTheDocument()
}

// updates rows by submitting a form...

// After update
{
  // since this is a different scope, we don't get an error to redeclare `rows` variable
  const rows = screen.getAllByRole('row')
  expect(within(rows[0]).getByRole('cell', { name: /active/i })).toBeInTheDocument()
}
```

üëâ **In short:**
- Use `{}` to scope queries and interactions.
- This keeps tests clean, avoids variable conflicts, and makes multi-step workflows easier to follow.

---

## Custom Matchers

Testing Library + Jest/Vitest DOM gives us a set of **DOM-aware matchers** that make tests much more expressive.

Here are the ones we use the most, with examples. [reference](https://github.com/testing-library/jest-dom?tab=readme-ov-file#custom-matchers)

### ‚úÖ `toHaveTextContent`

Asserts the visible **text inside an element**.

```tsx
const alert = screen.getByRole('alert')
expect(alert).toHaveTextContent(/profile updated/i)
```

This is better than `expect(alert.textContent).toMatch(...)` because it's built for DOM nodes.

### ‚úÖ `toHaveValue`

Asserts the **value of form inputs**.

```tsx
const input = screen.getByRole('textbox', { name: /first name/i })
await userEvent.type(input, 'Alice')

expect(input).toHaveValue('Alice')
```

This works for textboxes, selects, and other form controls.

### ‚úÖ `toBeEnabled` / `toBeDisabled`

Asserts whether a form control is enabled or disabled.

```tsx
const button = screen.getByRole('button', { name: /submit/i })
expect(button).toBeDisabled()

// after filling form
await userEvent.type(screen.getByRole('textbox', { name: /name/i }), 'Alice')
expect(button).toBeEnabled()
```

### ‚úÖ `toBeChecked`

For checkboxes, radio buttons, and switches.

```tsx
const checkbox = screen.getByRole('checkbox', { name: /accept terms/i })
await userEvent.click(checkbox)

expect(checkbox).toBeChecked()
```

üëâ **In short:**
- Use DOM-specific matchers for readability and better error messages.
- Prefer these over raw `.textContent`, `.value`, or `.getAttribute`.

---

## Error Messages Gotcha

When testing error messages, beware of how queries behave:

- **`getBy*`** ‚Üí throws if element not found.
- **`findBy*`** ‚Üí async version, retries until timeout.
- **`queryBy*`** ‚Üí returns `null` if not found (‚ö†Ô∏è can hide mistakes).

### The typo problem

If you inline error strings in your test, a typo could cause the test to pass incorrectly:

```tsx
// ‚ùå This test might pass incorrectly

// Submit form
await userEvent.click(screen.getByRole('button', { name: /submit/i }))

// Assert error message is present
expect(screen.getByText(/email is required/i)).toBeVisible();

// Fill email
await userEvent.type(
  screen.getByRole('textbox', { name: /first name/i }),
  'federico@every.io'
) // üëâ typing on the wrong input on purpose

// We made a typo: "requred" instead of "required"
expect(screen.queryByText(/email is requred/i)).not.toBeInTheDocument() // üëâ test will pass because of the message typo
```

This test passes, but not for the right reason! The element never existed because the regex was wrong.

### ‚úÖ Safer: use a constant

```tsx
test("shows email required error", async () => {
  // Submit form
  await userEvent.click(screen.getByRole('button', { name: /submit/i }))

  const ERROR_EMAIL_REQUIRED = /email is required/i

  // Error should now appear
  expect(await screen.findByText(ERROR_EMAIL_REQUIRED)).toBeVisible()

  // Fill email (on the wrong field again)
  await userEvent.type(
    screen.getByRole('textbox', { name: /first name/i }),
    'federico@every.io'
  )

  // ‚ùå Test will now fail because error is still be visible (because the email field is empty)
  expect(screen.queryByText(ERROR_EMAIL_REQUIRED)).not.toBeInTheDocument()
})
```

Now if we mistype the constant once, all tests referencing it will fail consistently, instead of silently passing.

### ‚úÖ Pattern for error messages

- Define error messages (or regexes) as **constants**.
- Use `queryBy*` for **absence** checks.
- Use `findBy*` for **presence** checks after interactions.

üëâ **In short:**
- Avoid inlined strings ‚Üí use constants to prevent typos.
- Don't use `queryBy*` to check presence.
- Prefer `findBy*` for async appearance of error messages.

---

## Asserting Network Requests

With **MSW**, the best practice is to: **instead of asserting that a particular request was made, test how your application reacts to that request.**

But on occasions, that's not possible. Think of executing a workflow where you end up with a success screen. How can you have more confidence on the result?

It would be tempting to have a variable inside our test and then do:

```tsx
expect(req.body).toEqual(myVariable)
```

Instead of that, we should **assert request payloads inside the handler**, not in the test.

This keeps tests focused on user behavior while MSW enforces that the right network payloads are sent.

üîó Reference: [MSW docs ‚Äì avoid request assertions](https://mswjs.io/docs/best-practices/avoid-request-assertions/)

### ‚ùå Tempting (but discouraged) pattern

It's common to see tests capture payloads in variables and then assert later:

```tsx
let capturedBody

server.use(
  graphql.mutation('CreateUser', async ({ variables }) => {
    capturedBody = variables
    return HttpResponse.json({
      data: { createUser: { id: '123', email: variables.email } },
    })
  })
)

await userEvent.type(screen.getByRole('textbox', { name: /email/i }), 'alice@example.com')
await userEvent.click(screen.getByRole('button', { name: /submit/i }))

// ‚ùå Test is asserting the request body manually
expect(capturedBody).toEqual({ email: 'alice@example.com' })
```

This works but leaks networking details into your test, which should really just focus on **user interaction** and **UI expectations**.

### ‚úÖ Better: assert inside the handler

Instead, validate the request payload directly in the handler. If the payload is wrong, throw an error (which will fail the test automatically):

```tsx
server.use(
  graphql.mutation('CreateUser', async ({ variables }) => {
    const expected = { email: 'alice@example.com' }

    if (variables.email !== expected.email) {
      return HttpResponse.json({
        errors: [
          {
            message: `Bad request: expected ${JSON.stringify(expected)}, got ${JSON.stringify(variables)}`,
          },
        ],
      })
    }

    return HttpResponse.json({
      data: {
        createUser: { id: '123', email: variables.email },
      },
    })
  })
)

// Test only asserts user-visible outcome
await userEvent.type(screen.getByRole('textbox', { name: /email/i }), 'alice@example.com')
await userEvent.click(screen.getByRole('button', { name: /submit/i }))

expect(await screen.findByText(/welcome, alice@example.com/i)).toBeInTheDocument()
```

Now:
- If the request body is wrong, the MSW handler fails immediately.
- Your test stays focused on what the **user sees**, not the internals of networking.

üëâ **In short:**
- Don't store request payloads in variables and assert them in the test.
- Validate request payloads **inside MSW handlers** instead.
- Keep tests user-centric; let MSW enforce request correctness.

---

## beforeEach with MSW

When working with **MSW**, it might seem convenient to define request handlers globally inside a `beforeEach` hook ‚Äî but this often leads to **coupled and hard-to-maintain tests**.

### ‚ùå Tempting (but problematic) pattern

```tsx
beforeEach(() => {
  server.use(
    graphql.query('GetUser', () =>
      HttpResponse.json({
        data: { user: { id: '1', name: 'Alice' } },
      }),
    ),
    graphql.mutation('CreateUser', () =>
      HttpResponse.json({
        data: { createUser: { id: '2', name: 'Bob' } },
      }),
    ),
  )
})

test('renders user profile', async () => {
  render(<UserProfile />)
  expect(await screen.findByText(/alice/i)).toBeInTheDocument()
})

test('creates new user', async () => {
  render(<CreateUserForm />)
  await userEvent.click(screen.getByRole('button', { name: /create/i }))
  expect(await screen.findByText(/bob/i)).toBeInTheDocument()
})
```

While this looks clean, it hides **what each test actually depends on**.

If one test needs a slightly different mock (e.g., error response or missing data), you now need to **override** the shared handler ‚Äî which complicates setup and increases cognitive load.

Worse, you may be mocking **queries or mutations that aren't even used** by some tests.

### ‚úÖ Better: define handlers inside each test

Keep handlers **close to the test logic**. This makes each test self-contained and easier to reason about.

```tsx
test('renders user profile', async () => {
  server.use(
    graphql.query('GetUser', () =>
      HttpResponse.json({
        data: { user: { id: '1', name: 'Alice' } },
      }),
    ),
  )

  render(<UserProfile />)
  expect(await screen.findByText(/alice/i)).toBeInTheDocument()
})

test('shows error state when user fetch fails', async () => {
  server.use(
    graphql.query('GetUser', () =>
      HttpResponse.json({
        errors: [{ message: 'Unauthorized' }],
      }),
    ),
  )

  render(<UserProfile />)
  expect(await screen.findByText(/unauthorized/i)).toBeInTheDocument()
})
```

Now:
- Each test defines **only the mocks it needs**.
- If the API behavior changes, failures clearly point to the relevant tests.
- Tests are easier to extend or delete independently.

üëâ **In short:**
- Don't define MSW handlers in `beforeEach`.
- Keep handlers inside individual tests ‚Äî they're easier to maintain and reason about.
- Avoid mocking data that isn't needed.

---

## Wrapping Up

This approach to testing has been a game-changer for us. By focusing on integration tests, user-centered queries, and MSW, we've created tests that are:
- **More maintainable** ‚Äî fewer tests, less duplication
- **More reliable** ‚Äî they catch real bugs instead of just implementation details
- **More readable** ‚Äî they describe what users actually do

The key takeaway: **test like a user, not like a developer**. Use accessible queries, avoid unnecessary mocks, and focus on integration over unit tests.

If you're interested in diving deeper, I highly recommend checking out:
- [Kent C. Dodds' testing philosophy](https://kentcdodds.com/blog/write-tests)
- [Testing Library's guiding principles](https://testing-library.com/docs/guiding-principles)
- [MSW documentation](https://mswjs.io/)

Happy testing! üöÄ

