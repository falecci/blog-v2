export const metadata = {
  title: "Why Integration Tests Beat Unit Tests (and When E2E Fails)",
  publishDate: "2025-01-27",
  description:
    "A practical guide to why integration tests deliver better value than unit tests, and when E2E tests become a burden.",
  draft: true,
};

If you've ever found yourself drowning in unit tests that mock everything, or spending hours debugging why your tests pass but your app fails in production, this post is for you.

We're going to dive into a testing philosophy that focuses on **integration tests** over unit tests, **user-centered testing** over implementation details, and **MSW** over mocking hooks. This approach has transformed how I write tests and I think it can help you too.

---

{/* <StackBlitz id="sb1-e79tzwoi" /> */}

## The Philosophy: Fewer Tests, Mostly Integration

There are many perspectives on testing: unit tests, integration tests, end-to-end (E2E) tests, and models like the [*testing pyramid*](https://martinfowler.com/articles/practical-test-pyramid.html).

Personally I like following the principle of ["Write tests. Not too many. Mostly integration"](https://kentcdodds.com/blog/write-tests), originally coined by Guillermo Rauch (Vercel) and expanded by Kent C. Dodds. The idea is simple: tests should deliver the **most value** for the **least cost**.

Tests come with basically two types of costs:
- **CI cost** (minutes spent running tests)
- **Developer cost** (time required to write and maintain them)

There are some delusions around having **100% code coverage**. That's not realistic and actually striving to get at it might not be good at all. Beyond a certain point, additional coverage doesn't justify the cost.

From my point of view, focusing on integration tests gives us the **best return on investment**. Let's dive into an example.

### Example: Testing a form

Imagine a classic form with inputs, selects, and a date picker. 

We could have unit tests for each input making sure `onChange` prop has been called with the right value and else. But at the end of the day, the integration of all the parts is not actually tested and it might fail.

What if we are doing some data transformation of our form values before sending it to our API? Sure, our `<DatePicker />` component is calling `onChange` with the right date value, but we may have a bug when posting this data:

```tsx
async function onSubmit(values: FormValues) {
    const timezonelessDate = new Date().toISOString().split('T')[2] // it should be actually 0 index -> this is undefined
    if (isValidBusinessDate(timezonelessDate)) // -> ❌ this will throw an error
    
    // ...
}
```

Our unit tests here would give us a **false sense of security** because they would still pass but our form submission is not actually working. There is nothing worse than a _lying test_.

If you are doing this work at a company, management/product people will come biting at you asking _why the user profile form failed if you spent time writing tests?_ and it's a valid complaint. Convincing product/management to spend time on technical stuff is _super hard_ so you don't want to lose the game there.

On the other hand, we could setup E2E tests with Playwright or Cypress. In this type of tests, we get a full browser so we are fully integrated. That is awesome!

But now we need to start doing some chores like spinning up the browser, setting up an environment, logging the user in our app, cleaning the environment afterwards and else. (Note: you can mock your requests and that would avoid having to deal with a DB but then that's not truly E2E).

These chores *takes time*. Imagine if you want to test a form that has multiple branches! Now you are getting full confidence in your tests but devs are truly unhappy because they need to run a +25 minutes CI to merge their already approved work.

If you can relate with what I just explained, welcome the world of integration tests. This type of tests will let us test A LOT. Things like a page with a table that's feed data from an API, clicking on a row to open a sheet that edits the record and then asserting the record has been updated in the table.

A straightforward approach might include three separate tests:

```tsx
test("renders form fields correctly", () => { ... })
test("shows validation errors on empty submission", async () => { ... })
test("submits form with valid data", async () => { ... })
```

These tests cover:
1. Rendering form fields
2. Showing validation errors
3. Submitting valid data

Looks good — but in reality, these three tests overlap heavily. They can actually be combined into a **single, stronger test**:

```tsx
test("submits form with valid data", async () => {
  render(<ProfilePage />);

  // Trigger validation errors
  await UserEvent.click(screen.getByRole("button", { name: /save/i }));
  expect(await screen.findByText(/username is required/i)).toBeInTheDocument();

  // Fill fields
  await UserEvent.type(screen.getByRole("textbox", { name: /username/i }), "alice");
  await UserEvent.selectOptions(screen.getByRole("combobox", { name: /manager/i }), "Michael Scott");

  // Submit successfully
  await UserEvent.click(screen.getByRole("button", { name: /save/i }));
  await expect.poll(() => screen.getByText("Profile updated")).toBeVisible();
});
```

This test checks:
- Validation errors appear
- Errors go away once fixed
- Form submission succeeds

As you can see, we are covering way more ground. And fewer tests means **lower maintenance overhead**.

---

## Why MSW?

[MSW](https://mswjs.io/) (Mock Service Worker) lets us intercept real network requests and provide handlers for queries and mutations. This way, we test **how our app actually works** — without mocking hooks or internal logic.

This is a game-changer because instead of mocking `useQuery` or `useMutation` hooks (which hides bugs), we let the real code run and intercept the actual network requests. This gives us confidence that our app works end-to-end, while still keeping tests fast and reliable.

---

## What about E2E tests?

We talked about costs earlier. E2E tests are great but they come with some drawbacks. First you need an environment running. That means resetting a DB, waiting for an API to run, authenticate a user.

Those seems like A LOT of things just to validate our form has the right error messages after submission, right :)?

We do want E2E tests for our most critical features (where we usually rely on 3rd party services) like paying a bill. And these tests should keep it only to filling data. No elements assertion, no validation errors triggered, etc.

---

## Wrapping Up

Integration tests give us the best of both worlds: the confidence of testing how things actually work together (like E2E) without the overhead of spinning up entire environments (like unit tests).

By focusing on integration tests, we create tests that are:
- **More maintainable** — fewer tests, less duplication
- **More reliable** — they catch real bugs instead of just implementation details
- **More readable** — they describe what users actually do

In the next post, we'll dive into how to write these tests using user-centered queries and accessibility patterns. Stay tuned!

If you're interested in diving deeper right now, I highly recommend checking out:
- [Kent C. Dodds' testing philosophy](https://kentcdodds.com/blog/write-tests)
- [MSW documentation](https://mswjs.io/)


