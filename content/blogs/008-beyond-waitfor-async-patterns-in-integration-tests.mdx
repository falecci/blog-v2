export const metadata = {
  title: "Beyond waitFor: Async Patterns in Integration Tests",
  publishDate: "2025-01-29",
  description:
    "Master async patterns in integration tests: findBy queries, expect.poll, and waitForElementToBeRemoved.",
  draft: true,
};

In the [previous post](/test-like-a-user-writing-accessible-tests), we covered how to write user-centered tests using accessible queries. Now let's tackle one of the trickiest parts of integration testing: handling async behavior.

---

## Await + findBy Instead of waitFor

When waiting for elements to appear in the DOM, always prefer the `findBy*` queries (`findByRole`, `findByText`, etc.).

### Why?

- `findBy*` queries **already include `waitFor` internally** ([reference](https://testing-library.com/docs/dom-testing-library/api-async/#findby-queries)).
- They retry until the element appears (or until the default timeout).
- This makes them more **concise** and **readable** than wrapping a `getBy*` in `waitFor`.
- For **custom assertions** on dynamic state, prefer **`expect.poll`** (Vitest) instead of `waitFor`. ([reference](https://vitest.dev/api/expect.html#poll))
- For elements that **disappear**, use `waitForElementToBeRemoved`. ([reference](https://testing-library.com/docs/dom-testing-library/api-async/#waitforelementtoberemoved))

### ‚úÖ Correct: using `findByRole`

```tsx
// Button appears after async save
await userEvent.click(screen.getByRole("button", { name: /save/i }));

// Wait for success toast
expect(await screen.findByRole("alert")).toHaveTextContent("Profile updated");
```

Here, `findByRole('alert')` automatically waits until the toast is in the DOM.

### ‚ùå Incorrect: wrapping `getBy*` in `waitFor`

```tsx
await userEvent.click(screen.getByRole("button", { name: /save/i }));

// Don't do this
await waitFor(() => {
  expect(screen.getByRole("alert")).toHaveTextContent("Profile updated");
});
```

This is redundant ‚Äî `findByRole` already does the waiting for you.

### ‚úÖ Custom assertions ‚Üí use `expect.poll`

Use `expect.poll` for polling assertions that aren't tied to element discovery.

```tsx
// Ensure button becomes disabled after click
await userEvent.click(screen.getByRole("button", { name: /save/i }));

await expect
  .poll(() => screen.getByRole("button", { name: /save/i }))
  .toBeDisabled();
```

This avoids the extra `waitFor` wrapper and is more idiomatic in Vitest.

### ‚úÖ When something disappears ‚Üí use `waitForElementToBeRemoved`

`waitForElementToBeRemoved` is the most expressive way to test that elements are removed from the DOM.

```tsx
// Loading spinner disappears after data loads
await waitForElementToBeRemoved(() =>
  screen.getByRole("status", { name: /loading/i })
);
```

### ‚úÖ Example with multiple steps

```tsx
// User submits form
await userEvent.click(screen.getByRole("button", { name: /submit/i }));

// Success message appears
expect(await screen.findByText(/successfully submitted/i)).toBeVisible();

// Button becomes disabled
await expect
  .poll(() => screen.getByRole("button", { name: /submit/i }))
  .toBeDisabled();

// Spinner goes away
await waitForElementToBeRemoved(() =>
  screen.getByRole("status", { name: /loading/i })
);
```

üëâ **In short:**

- Use `findBy*` for element discovery.
- Use **`expect.poll`** for dynamic assertions (enabled/disabled, value changes).
- Use `waitForElementToBeRemoved` when elements should disappear.
- Don't wrap `getBy*` with `waitFor` unless absolutely necessary.

---

## Scopes with `{}`

You can use plain `{}` blocks inside your tests to create **local scopes**.

This is useful when:

- A test has **multiple sections or steps** (e.g., a multi-step workflow, a form with multiple cards).
- You want to **reuse variable names** (e.g., `section`, `row`, `withinSection`) in different parts of the test without conflicts.
- It improves readability by clearly grouping queries and expectations by context.
- Scopes are foldable within most IDEs

### ‚úÖ Example: multi-section form

```tsx
// Accounting details section
{
  const section = screen.getByRole("section", { name: /accounting details/i });
  const inSection = within(section);

  const addressInput = inSection.getByRole("textbox", { name: /address/i });
  await userEvent.type(addressInput, "123 Main St");
  expect(addressInput).toHaveValue("123 Main St");
}

// Owner details section
{
  const section = screen.getByRole("section", { name: /owner details/i });
  const inSection = within(section);

  const firstNameInput = inSection.getByRole("textbox", {
    name: /first name/i,
  });
  await userEvent.type(firstNameInput, "Alice");
  expect(firstNameInput).toHaveValue("Alice");
}
```

Here, both blocks can safely use the same variable names (`section`, `inSection`) without clashing.

### ‚úÖ Example: re-querying rows

```tsx
// Before update
{
  const rows = screen.getAllByRole("row");
  expect(
    within(rows[0]).getByRole("cell", { name: /pending/i })
  ).toBeInTheDocument();
}

// updates rows by submitting a form...

// After update
{
  // since this is a different scope, we don't get an error to redeclare `rows` variable
  const rows = screen.getAllByRole("row");
  expect(
    within(rows[0]).getByRole("cell", { name: /active/i })
  ).toBeInTheDocument();
}
```

üëâ **In short:**

- Use `{}` to scope queries and interactions.
- This keeps tests clean, avoids variable conflicts, and makes multi-step workflows easier to follow.

---

## Custom Matchers

Testing Library + Jest/Vitest DOM gives us a set of **DOM-aware matchers** that make tests much more expressive.

Here are the ones we use the most, with examples. [reference](https://github.com/testing-library/jest-dom?tab=readme-ov-file#custom-matchers)

### ‚úÖ `toHaveTextContent`

Asserts the visible **text inside an element**.

```tsx
const alert = screen.getByRole("alert");
expect(alert).toHaveTextContent(/profile updated/i);
```

This is better than `expect(alert.textContent).toMatch(...)` because it's built for DOM nodes.

### ‚úÖ `toHaveValue`

Asserts the **value of form inputs**.

```tsx
const input = screen.getByRole("textbox", { name: /first name/i });
await userEvent.type(input, "Alice");

expect(input).toHaveValue("Alice");
```

This works for textboxes, selects, and other form controls.

### ‚úÖ `toBeEnabled` / `toBeDisabled`

Asserts whether a form control is enabled or disabled.

```tsx
const button = screen.getByRole("button", { name: /submit/i });
expect(button).toBeDisabled();

// after filling form
await userEvent.type(screen.getByRole("textbox", { name: /name/i }), "Alice");
expect(button).toBeEnabled();
```

### ‚úÖ `toBeChecked`

For checkboxes, radio buttons, and switches.

```tsx
const checkbox = screen.getByRole("checkbox", { name: /accept terms/i });
await userEvent.click(checkbox);

expect(checkbox).toBeChecked();
```

üëâ **In short:**

- Use DOM-specific matchers for readability and better error messages.
- Prefer these over raw `.textContent`, `.value`, or `.getAttribute`.

---

## Error Messages Gotcha

When testing error messages, beware of how queries behave:

- **`getBy*`** ‚Üí throws if element not found.
- **`findBy*`** ‚Üí async version, retries until timeout.
- **`queryBy*`** ‚Üí returns `null` if not found (‚ö†Ô∏è can hide mistakes).

### The typo problem

If you inline error strings in your test, a typo could cause the test to pass incorrectly:

```tsx
// ‚ùå This test might pass incorrectly

// Submit form
await userEvent.click(screen.getByRole("button", { name: /submit/i }));

// Assert error message is present
expect(screen.getByText(/email is required/i)).toBeVisible();

// Fill email
await userEvent.type(
  screen.getByRole("textbox", { name: /first name/i }),
  "federico@every.io"
); // üëâ typing on the wrong input on purpose

// We made a typo: "requred" instead of "required"
expect(screen.queryByText(/email is requred/i)).not.toBeInTheDocument(); // üëâ test will pass because of the message typo
```

This test passes, but not for the right reason! The element never existed because the regex was wrong.

### ‚úÖ Safer: use a constant

```tsx
test("shows email required error", async () => {
  // Submit form
  await userEvent.click(screen.getByRole("button", { name: /submit/i }));

  const ERROR_EMAIL_REQUIRED = /email is required/i;

  // Error should now appear
  expect(await screen.findByText(ERROR_EMAIL_REQUIRED)).toBeVisible();

  // Fill email (on the wrong field again)
  await userEvent.type(
    screen.getByRole("textbox", { name: /first name/i }),
    "federico@every.io"
  );

  // ‚ùå Test will now fail because error is still be visible (because the email field is empty)
  expect(screen.queryByText(ERROR_EMAIL_REQUIRED)).not.toBeInTheDocument();
});
```

Now if we mistype the constant once, all tests referencing it will fail consistently, instead of silently passing.

### ‚úÖ Pattern for error messages

- Define error messages (or regexes) as **constants**.
- Use `queryBy*` for **absence** checks.
- Use `findBy*` for **presence** checks after interactions.

üëâ **In short:**

- Avoid inlined strings ‚Üí use constants to prevent typos.
- Don't use `queryBy*` to check presence.
- Prefer `findBy*` for async appearance of error messages.

---

## Wrapping Up

Mastering async patterns in tests takes practice, but once you get the hang of `findBy*`, `expect.poll`, and `waitForElementToBeRemoved`, your tests become much more reliable and easier to read.

In the final post of this series, we'll dive deep into MSW best practices‚Äîhow to mock network requests effectively without creating brittle tests.

If you're interested in diving deeper, check out:

- [Vitest expect.poll documentation](https://vitest.dev/api/expect.html#poll)
- [Testing Library async queries](https://testing-library.com/docs/dom-testing-library/api-async/#findby-queries)
